<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FrameEngine V8 - 精简工坊</title>
    <!-- 引入Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 引入 JSZip 库用于批量打包 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <!-- 使用Inter字体 -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', 'Helvetica Neue', 'Arial', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'sans-serif';
            overscroll-behavior: none;
            display: flex;
            flex-direction: column;
            height: 100vh;
            background-color: #111827; /* gray-900 */
        }
        /* ... (保留 V7 的所有样式) ... */
        input[type="range"] { -webkit-appearance: none; appearance: none; width: 100%; height: 6px; background: #4a5568; border-radius: 3px; outline: none; opacity: 0.9; transition: opacity .2s; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 18px; height: 18px; background: #6366f1; border-radius: 50%; border: 2px solid white; cursor: pointer; }
        input[type="range"]::-moz-range-thumb { width: 18px; height: 18px; background: #6366f1; border-radius: 50%; border: 2px solid white; cursor: pointer; }
        input[type="file"]::file-selector-button { background-color: #6366f1; color: white; border: none; padding: 0.5rem 1rem; border-radius: 0.375rem; cursor: pointer; transition: background-color 0.2s; }
        input[type="file"]::file-selector-button:hover { background-color: #4f46e5; }
        .radio-group input:checked + label { background-color: #6366f1; color: white; border-color: #6366f1; }
        .radio-group label { transition: all 0.2s; }
        #lockRadius.locked { background-color: #6366f1; color: white; }
        #lockRadius.locked svg { stroke: white; }
        #lockRadius.unlocked { background-color: #4b5563; color: #d1d5db; }
        #lockRadius.unlocked svg { stroke: #d1d5db; }
        #imageGallery { display: flex; overflow-x: auto; overflow-y: hidden; padding-bottom: 8px; white-space: nowrap; }
        .thumbnail { width: 64px; height: 64px; object-fit: cover; border-radius: 0.375rem; border: 2px solid #4b5563; cursor: pointer; margin-right: 8px; transition: border-color 0.2s; }
        .thumbnail:hover { border-color: #818cf8; }
        .thumbnail.selected { border-color: #6366f1; box-shadow: 0 0 0 2px #6366f1; }
        #imageGallery::-webkit-scrollbar { display: none; }
        #imageGallery { -ms-overflow-style: none; scrollbar-width: none; }
        .nav-button { padding: 0.5rem 1.25rem; font-size: 0.875rem; font-weight: 500; color: #d1d5db; border-bottom: 3px solid transparent; transition: all 0.2s; }
        .nav-button:hover { color: white; background-color: #374151; }
        .nav-button.active { color: white; border-bottom-color: #6366f1; }
        .ratio-planner {
            position: relative; width: 100%; padding-top: 100%;
            background-color: #27272a; border: 2px dashed #4b5563;
            border-radius: 0.375rem; cursor: crosshair; overflow: hidden;
        }
        .drawn-rect {
            position: absolute; background-color: rgba(99, 102, 241, 0.4);
            border: 1px solid #c7d2fe; box-sizing: border-box; display: none;
        }
    </style>
</head>
<body class="bg-gray-900">

    <!-- 1. 顶部导航 (模块切换器) -->
    <nav class="w-full bg-gray-800 shadow-lg flex-shrink-0 z-10">
        <!-- ... (V7 导航栏代码不变) ... -->
        <div class="max-w-7xl mx-auto px-4">
            <div class="flex justify-start space-x-2">
                <button id="navFrame" class="nav-button active">
                    <svg class="w-5 h-5 inline-block mr-1" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M9.75 3.104v5.714a2.25 2.25 0 01-.5 1.591L5.22 15.75M9.75 3.104A2.25 2.25 0 007.5 1.5h-3A2.25 2.25 0 002.25 3.75v16.5A2.25 2.25 0 004.5 22.5h15a2.25 2.25 0 002.25-2.25V3.75A2.25 2.25 0 0019.5 1.5h-3a2.25 2.25 0 00-2.25 1.604m-7.5 0v5.714m0 0a2.25 2.25 0 01.5 1.591L18.78 15.75m-9.03 0a2.25 2.25 0 00-2.25 2.25v.168a2.25 2.25 0 002.25 2.25h.168a2.25 2.25 0 002.25-2.25v-.168a2.25 2.25 0 00-2.25-2.25z" /></svg>
                    画框工坊
                </button>
                <button id="navWall" class="nav-button">
                    <svg class="w-5 h-5 inline-block mr-1" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M2.25 7.125C2.25 6.504 2.754 6 3.375 6h6C9.996 6 10.5 6.504 10.5 7.125v3.75c0 .621-.504 1.125-1.125 1.125h-6C2.754 12 2.25 11.496 2.25 10.875V7.125zM13.5 7.125C13.5 6.504 14.004 6 14.625 6h6c.621 0 1.125.504 1.125 1.125v3.75c0 .621-.504 1.125-1.125 1.125h-6c-.621 0-1.125-.504-1.125-1.125V7.125zM2.25 16.125c0-.621.504-1.125 1.125-1.125h6c.621 0 1.125.504 1.125 1.125v3.75c0 .621-.504 1.125-1.125 1.125h-6c-.621 0-1.125-.504-1.125-1.125V16.125zM13.5 16.125c0-.621 1.004-1.125 1.625-1.125h6c.621 0 1.125.504 1.125 1.125v3.75c0 .621-.504 1.125-1.125 1.125h-6c-.621 0-1.125-.504-1.125-1.125V16.125z" /></svg>
                    照片墙
                </button>
            </div>
        </nav>

    <!-- 2. 主体内容区 (可切换) -->
    <div class="flex-1 overflow-hidden">
        
        <!-- ========================== -->
        <!-- 模块 A: 画框工坊 (Frame Module) -->
        <!-- ========================== -->
        <div id="frameModule" class="flex flex-col md:flex-row h-full">
            <!-- 2A.1. 画框控制面板 (左侧) -->
            <aside class="w-full md:w-96 bg-gray-800 shadow-2xl overflow-y-auto p-5 md:p-6 space-y-5 flex-shrink-0 h-1/2 md:h-full">
                <!-- V8 标题 -->
                <h1 class="text-2xl font-bold text-white mb-4">FrameEngine <span class="text-indigo-400">V8</span></h1>
                
                <!-- 上传 -->
                <div>
                    <label class="block text-sm font-medium text-gray-300 mb-2">1. 上传图片 (支持批量)</label>
                    <input type="file" id="imageLoader" accept="image/*" multiple class="block w-full text-sm text-gray-400 file:text-sm file:font-semibold">
                </div>
                <!-- 图库 -->
                <div id="galleryWrapper" class="hidden">
                    <label class="block text-sm font-medium text-gray-300 mb-2">选择图片预览</label>
                    <div id="imageGallery" class="bg-gray-700 p-2 rounded-lg"></div>
                </div>

                <!-- 画框控件 -->
                <div id="controlsWrapper" class="space-y-5 opacity-50 pointer-events-none transition-opacity duration-300">
                    <!-- 布局与裁剪 (V7 结构) -->
                    <div class="bg-gray-700 p-4 rounded-lg">
                        <h3 class="font-semibold mb-3 text-white">2. 布局与裁剪</h3>
                        <div class="grid grid-cols-2 gap-3">
                            <div>
                                <label for="aspectRatio" class="block text-sm font-medium text-gray-300 mb-1">宽高比</label>
                                <select id="aspectRatio" class="w-full bg-gray-800 border-gray-600 rounded-md py-2 px-3 focus:ring-indigo-500 focus:border-indigo-500 text-sm">
                                    <option value="original">原始比例</option>
                                    <option value="1:1">1:1</option> <option value="4:5">4:5</option>
                                    <option value="5:4">5:4</option> <option value="16:9">16:9</option>
                                    <option value="9:16">9:16</option>
                                    <option value="custom">自定义 (绘制)</option>
                                </select>
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-300 mb-1">填充模式</label>
                                <div class="flex radio-group rounded-md">
                                    <input type="radio" name="fitMode" id="fit" value="fit" class="sr-only" checked>
                                    <label for="fit" class="flex-1 text-center py-2 px-3 text-sm border border-gray-600 rounded-l-md cursor-pointer">适应</label>
                                    <input type="radio" name="fitMode" id="fill" value="fill" class="sr-only">
                                    <label for="fill" class="flex-1 text-center py-2 px-3 text-sm border-t border-b border-r border-gray-600 rounded-r-md cursor-pointer">填充</label>
                                </div>
                            </div>
                        </div>
                        
                        <!-- 画框工坊的画幅规划器 (V7 结构) -->
                        <div id="frameRatioPlannerContainer" class="mt-3 hidden">
                            <label class="block text-sm font-medium text-gray-300 mb-2">绘制自定义宽高比</label>
                            <div id="frameRatioPlanner" class="ratio-planner">
                                <div id="frameDrawnRect" class="drawn-rect"></div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- 其他模块 (V7 结构不变) -->
                    <div class="bg-gray-700 p-4 rounded-lg space-y-4">
                        <h3 class="font-semibold text-white">3. 画框系统 (双层)</h3>
                        <div>
                            <label class="block text-sm font-medium text-gray-300">外层画框 (Frame)</label>
                            <div class="flex space-x-2 mt-2">
                                <select id="frameType" class="flex-1 bg-gray-800 border-gray-600 rounded-md py-1.5 px-2 focus:ring-indigo-500 focus:border-indigo-500 text-sm">
                                    <option value="solid">纯色</option> <option value="gradient">渐变</option>
                                    <option value="wood">木纹</option> <option value="stipple">麻布</option>
                                    <option value="stripes">条纹</option> <option value="checker">棋盘</option>
                                </select>
                                <input type="color" id="frameColor1" value="#374151" class="w-9 h-9 p-0 border-none rounded-md bg-gray-800 cursor-pointer">
                                <input type="color" id="frameColor2" value="#111827" class="w-9 h-9 p-0 border-none rounded-md bg-gray-800 cursor-pointer">
                            </div>
                            <input type="range" id="frameSize" min="0" max="200" value="30" class="mt-3">
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-300">内层卡纸 (Mat)</label>
                            <div class="flex space-x-2 mt-2">
                                <span class="flex-1"></span>
                                <input type="color" id="matColor" value="#F3F4F6" class="w-9 h-9 p-0 border-none rounded-md bg-gray-800 cursor-pointer">
                            </div>
                            <input type="range" id="matSize" min="0" max="200" value="50" class="mt-3">
                        </div>
                    </div>
                    <div class="bg-gray-700 p-4 rounded-lg">
                        <div class="flex justify-between items-center mb-3">
                            <h3 class="font-semibold text-white">4. 四角样式</h3>
                            <button id="lockRadius" class="locked p-1.5 rounded-md transition-all">
                                <svg id="lockIcon" class="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M16.5 10.5V6.75a4.5 4.5 0 00-9 0v3.75m-.75 11.25h10.5a2.25 2.25 0 002.25-2.25v-6.75a2.25 2.25 0 00-2.25-2.25H6.75a2.25 2.25 0 00-2.25 2.25v6.75a2.25 2.25 0 002.25 2.25z" /></svg>
                                <svg id="unlockIcon" class="w-5 h-5 hidden" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 10.5V6.75a4.5 4.5 0 00-9 0v3.75m.75 11.25H18a2.25 2.25 0 002.25-2.25v-6.75a2.25 2.25 0 00-2.25-2.25H6.75a2.25 2.25 0 00-2.25 2.25v6.75a2.25 2.25 0 002.25 2.25z" /></svg>
                            </button>
                        </div>
                        <div class="grid grid-cols-2 gap-x-4 gap-y-2">
                            <label class="text-sm">左上</label> <label class="text-sm">右上</label>
                            <input type="range" id="radiusTL" min="0" max="300" value="0" class="col-span-1 corner-radius">
                            <input type="range" id="radiusTR" min="0" max="300" value="0" class="col-span-1 corner-radius">
                            <label class="text-sm mt-2">左下</label> <label class="text-sm mt-2">右下</label>
                            <input type="range" id="radiusBL" min="0" max="300" value="0" class="col-span-1 corner-radius">
                            <input type="range" id="radiusBR" min="0" max="300" value="0" class="col-span-1 corner-radius">
                        </div>
                    </div>
                    <div class="bg-gray-700 p-4 rounded-lg space-y-4">
                        <h3 class="font-semibold text-white">5. 光影特效</h3>
                        <div>
                            <label class="block text-sm font-medium text-gray-300">边缘柔光 (Vignette)</label>
                            <div class="flex space-x-2 mt-2">
                                <input type="color" id="vignetteColor" value="#000000" class="w-9 h-9 p-0 border-none rounded-md bg-gray-800 cursor-pointer">
                                <input type="range" id="vignetteStrength" min="0" max="100" value="0" class="flex-1">
                            </div>
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-300">画框投影 (Shadow)</label>
                            <div class="flex space-x-2 mt-2">
                                <input type="color" id="shadowColor" value="#000000" class="w-9 h-9 p-0 border-none rounded-md bg-gray-800 cursor-pointer">
                                <input type="range" id="shadowBlur" min="0" max="100" value="0" class="flex-1" title="阴影模糊">
                            </div>
                            <div class="grid grid-cols-2 gap-x-4 gap-y-2 mt-3">
                                <label class="text-sm">X 偏移</label> <label class="text-sm">Y 偏移</label>
                                <input type="range" id="shadowOffsetX" min="-50" max="50" value="0">
                                <input type="range" id="shadowOffsetY" min="-50" max="50" value="0">
                            </div>
                        </div>
                    </div>
                    <div class="bg-gray-700 p-4 rounded-lg">
                        <h3 class="font-semibold mb-3 text-white">6. 导出作品 (单张)</h3>
                        <div class="flex space-x-2">
                            <input type="text" id="filename" value="framed-batch" placeholder="文件名" class="flex-1 bg-gray-800 border-gray-600 rounded-md py-2 px-3 focus:ring-indigo-500 focus:border-indigo-500 text-sm">
                            <select id="format" class="bg-gray-800 border-gray-600 rounded-md py-2 px-3 focus:ring-indigo-500 focus:border-indigo-500 text-sm">
                                <option value="image/png">PNG</option> <option value="image/jpeg">JPEG</option>
                            </select>
                        </div>
                        <button id="downloadBtn" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2.5 px-4 rounded-md mt-3 transition-all duration-200 flex items-center justify-center space-x-2 disabled:opacity-50">
                            <svg id="downloadSpinner" class="animate-spin -ml-1 mr-2 h-5 w-5 text-white hidden" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                            </svg>
                            <span id="downloadBtnText">批量导出 (ZIP)</span>
                        </button>
                    </div>
                </div>
            </aside>

            <!-- 2A.2. 画框预览区域 (右侧) -->
            <main class="flex-1 bg-gray-900 flex items-center justify-center p-4 md:p-8 overflow-hidden h-1/2 md:h-full">
                <!-- ... (V7 画框工坊预览区代码不变) ... -->
                <div id="canvasContainer" class="w-full h-full flex items-center justify-center">
                    <canvas id="previewCanvas" class="max-w-full max-h-full rounded-lg shadow-lg" style="background-color: #1f2937;"></canvas>
                </div>
                <div id="placeholder" class="text-gray-500 text-lg text-center select-none">
                    <svg class="w-24 h-24 mx-auto text-gray-600" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M2.25 15.75l5.159-5.159a2.25 2.25 0 013.182 0l5.159 5.159m-1.5-1.5l1.409-1.409a2.25 2.25 0 013.182 0l2.909 2.909m-18 3.75h16.5a1.5 1.5 0 001.5-1.5V6a1.5 1.5 0 00-1.5-1.5H3.75A1.5 1.5 0 002.25 6v12a1.5 1.5 0 001.5 1.5zm10.5-11.25h.008v.008h-.008V8.25zm.375 0a.375.375 0 11-.75 0 .375.375 0 01.75 0z" /></svg>
                    <p class="mt-2">请在左侧上传一张或多张图片</p>
                </div>
            </main>
        </div>
        
        <!-- ========================== -->
        <!-- 模块 B: 照片墙 (Wall Module) -->
        <!-- ========================== -->
        <div id="wallModule" class="hidden flex-col md:flex-row h-full">
            <!-- 2B.1. 照片墙控制面板 (左侧) -->
            <aside class="w-full md:w-96 bg-gray-800 shadow-2xl overflow-y-auto p-5 md:p-6 space-y-5 flex-shrink-0">
                <!-- ... (V7 照片墙侧边栏代码) ... -->
                <h1 class="text-2xl font-bold text-white mb-4">照片墙 <span class="text-indigo-400">布局</span></h1>
                
                <div id="wallControlsWrapper" class="space-y-5">
                    <div class="bg-gray-700 p-4 rounded-lg">
                        <h3 class="font-semibold mb-3 text-white">1. 布局画幅</h3>
                        <div>
                            <label class="block text-sm font-medium text-gray-300 mb-2">
                                绘制目标画幅 (定义宽高比)
                            </label>
                            <div id="wallRatioPlanner" class="ratio-planner">
                                <div id="wallDrawnRect" class="drawn-rect"></div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- *** V8 关键修改: "随机变换" 按钮已从此区域移除 *** -->
                    <div class="bg-gray-700 p-4 rounded-lg">
                        <h3 class="font-semibold mb-3 text-white">2. 布局风格</h3>
                        <div class="space-y-3">
                            <div>
                                <label for="layoutMode" class="block text-sm font-medium text-gray-300 mb-1">布局模式</label>
                                <select id="layoutMode" class="w-full bg-gray-800 border-gray-600 rounded-md py-2 px-3 focus:ring-indigo-500 focus:border-indigo-500 text-sm">
                                    <option value="masonry">智能瀑布流 (自动拟合)</option>
                                    <option value="random">随机散布 (自动填充)</option>
                                </select>
                            </div>
                            <div>
                                <label for="wallCompactness" class="block text-sm font-medium text-gray-300 mb-1">紧凑度 / 缩放</label>
                                <input type="range" id="wallCompactness" min="0" max="100" value="20">
                            </div>
                            <!-- 随机变换按钮已被删除 -->
                        </div>
                    </div>
                    
                    <div class="bg-gray-700 p-4 rounded-lg">
                        <h3 class="font-semibold mb-3 text-white">3. 预览设置</h3>
                        <div>
                            <label for="wallBgColor" class="block text-sm font-medium text-gray-300 mb-1">预览背景色</label>
                            <input type="color" id="wallBgColor" value="#1f2937" class="w-full h-10 p-0 border-none rounded-md bg-gray-800 cursor-pointer">
                        </div>
                    </div>
                    
                    <div class="bg-gray-700 p-4 rounded-lg">
                        <h3 class="font-semibold mb-3 text-white">4. 导出照片墙</h3>
                        <p class="text-sm text-gray-400 mb-2">将导出单张透明背景的 PNG 图片。</p>
                        <button id="exportWallBtn" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2.5 px-4 rounded-md mt-3 transition-all duration-200 flex items-center justify-center space-x-2 disabled:opacity-50">
                            <svg id="exportWallSpinner" class="animate-spin -ml-1 mr-2 h-5 w-5 text-white hidden" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                            </svg>
                            <span id="exportWallBtnText">导出照片墙 (PNG)</span>
                        </button>
                    </div>
                </div>
            </aside>
            
            <!-- 2B.2. 照片墙预览区域 (右侧) -->
            <main id="wallCanvasContainer" class="flex-1 bg-gray-900 flex items-center justify-center p-4 md:p-8 overflow-auto h-full">
                <!-- V7 预览画布 (带缩放) -->
                <canvas id="wallCanvas" class="shadow-lg max-w-full max-h-full"></canvas>
            </main>
        </div>

    </div>
    
    <!-- 离屏画布, 保持不变 -->
    <canvas id="sourceCanvas" class="hidden"></canvas>
    <canvas id="textureCanvas" class="hidden"></canvas>
    <canvas id="frameRenderCanvas" class="hidden"></canvas>


    <script>
        // 确保 JSZip 在全局
        // (在实际使用中，依赖 `https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js`)
        
        document.addEventListener('DOMContentLoaded', () => {
            // --- 全局状态 (V7 不变) ---
            let imageList = [];
            let currentPreviewIndex = 0;
            let frameSettings = {};
            let wallSettings = {};
            let isRadiusLocked = true;
            let texturePatterns = {};
            let isWallRendering = false;
            let customFrameAspectRatio = 1.0;
            let wallTargetAspectRatio = 1.0;
            
            // --- DOM 元素: 导航 (V7 不变) ---
            const navFrame = document.getElementById('navFrame');
            const navWall = document.getElementById('navWall');
            const frameModule = document.getElementById('frameModule');
            const wallModule = document.getElementById('wallModule');

            // --- DOM 元素: 画框工坊 (Module A) (V7 不变) ---
            const imageLoader = document.getElementById('imageLoader');
            const previewCanvas = document.getElementById('previewCanvas');
            const previewCtx = previewCanvas.getContext('2d');
            const controlsWrapper = document.getElementById('controlsWrapper');
            const placeholder = document.getElementById('placeholder');
            const downloadBtn = document.getElementById('downloadBtn');
            const downloadBtnText = document.getElementById('downloadBtnText');
            const downloadSpinner = document.getElementById('downloadSpinner');
            const lockRadiusBtn = document.getElementById('lockRadius');
            const lockIcon = document.getElementById('lockIcon');
            const unlockIcon = document.getElementById('unlockIcon');
            const radiusSliders = document.querySelectorAll('.corner-radius');
            const galleryWrapper = document.getElementById('galleryWrapper');
            const imageGallery = document.getElementById('imageGallery');
            const frameRatioPlannerContainer = document.getElementById('frameRatioPlannerContainer');

            // --- DOM 元素: 照片墙 (Module B) ---
            // *** V8 关键修改: 移除 regenerateLayoutBtn ***
            const wallCanvas = document.getElementById('wallCanvas');
            const wallCtx = wallCanvas.getContext('2d');
            const wallCanvasContainer = document.getElementById('wallCanvasContainer');
            const layoutModeSelect = document.getElementById('layoutMode');
            const wallCompactnessSlider = document.getElementById('wallCompactness');
            // const regenerateLayoutBtn = document.getElementById('regenerateLayoutBtn'); // 已移除
            const wallBgColorInput = document.getElementById('wallBgColor');
            const exportWallBtn = document.getElementById('exportWallBtn');
            const exportWallSpinner = document.getElementById('exportWallSpinner');
            const exportWallBtnText = document.getElementById('exportWallBtnText');

            // --- DOM 元素: 离屏画布 (V7 不变) ---
            const textureCanvas = document.getElementById('textureCanvas');
            const textureCtx = textureCanvas.getContext('2d');
            const frameRenderCanvas = document.getElementById('frameRenderCanvas');
            const frameRenderCtx = frameRenderCanvas.getContext('2d');
            
            // --- 画框工坊: 控制器 (V7 不变) ---
            const frameInputs = {
                aspectRatio: document.getElementById('aspectRatio'),
                fitMode: () => document.querySelector('input[name="fitMode"]:checked').value,
                frameType: document.getElementById('frameType'),
                frameColor1: document.getElementById('frameColor1'),
                frameColor2: document.getElementById('frameColor2'),
                frameSize: document.getElementById('frameSize'),
                matColor: document.getElementById('matColor'),
                matSize: document.getElementById('matSize'),
                radiusTL: document.getElementById('radiusTL'),
                radiusTR: document.getElementById('radiusTR'),
                radiusBL: document.getElementById('radiusBL'),
                radiusBR: document.getElementById('radiusBR'),
                vignetteColor: document.getElementById('vignetteColor'),
                vignetteStrength: document.getElementById('vignetteStrength'),
                shadowColor: document.getElementById('shadowColor'),
                shadowBlur: document.getElementById('shadowBlur'),
                shadowOffsetX: document.getElementById('shadowOffsetX'),
                shadowOffsetY: document.getElementById('shadowOffsetY'),
                filename: document.getElementById('filename'),
                format: document.getElementById('format'),
            };

            // --- 1. 初始化 ---
            function init() {
                updatePatterns();
                navFrame.addEventListener('click', () => switchModule('frame'));
                navWall.addEventListener('click', () => switchModule('wall'));
                imageLoader.addEventListener('change', handleImageUpload);
                downloadBtn.addEventListener('click', batchExport);
                lockRadiusBtn.addEventListener('click', toggleRadiusLock);
                
                // 绑定画框工坊控件
                Object.values(frameInputs).forEach(input => {
                    if (typeof input !== 'function' && input.id !== 'aspectRatio') {
                         input.addEventListener('input', scheduleRedrawFrame);
                    }
                });
                frameInputs.aspectRatio.addEventListener('change', () => {
                    if (frameInputs.aspectRatio.value === 'custom') {
                        frameRatioPlannerContainer.classList.remove('hidden');
                    } else {
                        frameRatioPlannerContainer.classList.add('hidden');
                    }
                    scheduleRedrawFrame();
                });
                document.querySelectorAll('input[name="fitMode"]').forEach(radio => {
                    radio.addEventListener('change', scheduleRedrawFrame);
                });
                radiusSliders.forEach(slider => {
                    slider.addEventListener('input', handleRadiusChange);
                });
                frameInputs.frameColor1.addEventListener('input', updatePatterns);
                frameInputs.frameColor2.addEventListener('input', updatePatterns);
                
                // 绑定照片墙控件
                // *** V8 关键修改: 移除 regenerateLayoutBtn 的监听器 ***
                wallBgColorInput.addEventListener('input', (e) => {
                    wallCanvasContainer.style.backgroundColor = e.target.value;
                });
                // regenerateLayoutBtn.addEventListener('click', renderWall); // 已移除
                layoutModeSelect.addEventListener('input', renderWall);
                wallCompactnessSlider.addEventListener('input', renderWall);
                exportWallBtn.addEventListener('click', exportWall);
                
                // 初始化两个画幅规划器 (V7 不变)
                setupRatioPlanner(
                    document.getElementById('frameRatioPlanner'),
                    document.getElementById('frameDrawnRect'),
                    (newRatio, rect) => {
                        customFrameAspectRatio = newRatio;
                        setDrawnRect(document.getElementById('frameDrawnRect'), rect);
                        scheduleRedrawFrame();
                    }
                );
                
                setupRatioPlanner(
                    document.getElementById('wallRatioPlanner'),
                    document.getElementById('wallDrawnRect'),
                    (newRatio, rect) => {
                        wallTargetAspectRatio = newRatio;
                        setDrawnRect(document.getElementById('wallDrawnRect'), rect);
                        renderWall();
                    }
                );
            }

            // --- 2. 模块切换 (V7 不变) ---
            function switchModule(moduleName) {
                if (moduleName === 'wall') {
                    if (imageList.length === 0) {
                        alert("请先在“画框工坊”上传至少一张图片。");
                        return;
                    }
                    frameModule.classList.add('hidden');
                    wallModule.classList.remove('hidden');
                    wallModule.classList.add('flex');
                    navFrame.classList.remove('active');
                    navWall.classList.add('active');
                    wallCanvasContainer.style.backgroundColor = wallBgColorInput.value;
                    renderWall();
                } else {
                    frameModule.classList.remove('hidden');
                    wallModule.classList.add('hidden');
                    wallModule.classList.remove('flex');
                    navFrame.classList.add('active');
                    navWall.classList.remove('active');
                }
            }
            
            // --- 3. 核心绘制函数 (V7 不变) ---
            function drawFramedImage(ctx, image, settings, canvasWidth, canvasHeight) {
                const originalWidth = image.width;
                const originalHeight = image.height;
                const originalRatio = originalWidth / originalHeight;
                let targetRatio;
                if (settings.aspectRatio === 'original') {
                    targetRatio = originalRatio;
                } else if (settings.aspectRatio === 'custom') {
                    targetRatio = customFrameAspectRatio;
                } else {
                    const [w, h] = settings.aspectRatio.split(':').map(Number);
                    targetRatio = w / h;
                }
                if (targetRatio > originalRatio) {
                    canvasHeight = canvasWidth / targetRatio;
                } else {
                    canvasWidth = canvasHeight * targetRatio;
                }
                canvasWidth = Math.round(canvasWidth);
                canvasHeight = Math.round(canvasHeight);
                ctx.canvas.width = canvasWidth;
                ctx.canvas.height = canvasHeight;
                ctx.clearRect(0, 0, canvasWidth, canvasHeight);
                const frame = settings.frameSize;
                const mat = settings.matSize;
                const totalBorder = frame + mat;
                if (settings.shadowBlur > 0 || settings.shadowOffsetX !== 0 || settings.shadowOffsetY !== 0) {
                    ctx.save();
                    ctx.shadowColor = hexToRgba(settings.shadowColor, 0.75);
                    ctx.shadowBlur = settings.shadowBlur;
                    ctx.shadowOffsetX = settings.shadowOffsetX;
                    ctx.shadowOffsetY = settings.shadowOffsetY;
                }
                ctx.fillStyle = getFillStyle(ctx, settings.frameType, 0, 0, canvasWidth, canvasHeight);
                drawRoundedRect(ctx, 0, 0, canvasWidth, canvasHeight, settings.radii);
                ctx.fill();
                if (settings.shadowBlur > 0 || settings.shadowOffsetX !== 0 || settings.shadowOffsetY !== 0) {
                    ctx.restore();
                }
                if (mat > 0) {
                    ctx.fillStyle = settings.matColor;
                    const matRadii = getInnerRadii(settings.radii, frame);
                    drawRoundedRect(ctx, frame, frame, canvasWidth - frame * 2, canvasHeight - frame * 2, matRadii);
                    ctx.fill();
                }
                ctx.save();
                const imageRadii = getInnerRadii(settings.radii, totalBorder);
                drawRoundedRect(ctx, totalBorder, totalBorder, canvasWidth - totalBorder * 2, canvasHeight - totalBorder * 2, imageRadii);
                ctx.clip();
                const imageRect = { x: totalBorder, y: totalBorder, w: canvasWidth - totalBorder * 2, h: canvasHeight - totalBorder * 2 };
                if (imageRect.w > 0 && imageRect.h > 0) {
                    const imageTargetRatio = imageRect.w / imageRect.h;
                    let sx = 0, sy = 0, sw = originalWidth, sh = originalHeight;
                    let dx = imageRect.x, dy = imageRect.y, dw = imageRect.w, dh = imageRect.h;
                    if (settings.fitMode === 'fit') {
                        if (originalRatio > imageTargetRatio) {
                            dh = imageRect.w / originalRatio; dy = imageRect.y + (imageRect.h - dh) / 2; dw = imageRect.w;
                        } else {
                            dw = imageRect.h * originalRatio; dx = imageRect.x + (imageRect.w - dw) / 2; dh = imageRect.h;
                        }
                    } else {
                         if (originalRatio > imageTargetRatio) {
                            sw = originalHeight * imageTargetRatio; sx = (originalWidth - sw) / 2;
                        } else {
                            sh = originalWidth / imageTargetRatio; sy = (originalHeight - sh) / 2;
                        }
                    }
                    ctx.drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh);
                }
                ctx.restore();
                if (settings.vignetteStrength > 0) {
                    ctx.save();
                    const strength = settings.vignetteStrength / 100;
                    const gradient = ctx.createRadialGradient(
                        canvasWidth / 2, canvasHeight / 2, canvasWidth * 0.2,
                        canvasWidth / 2, canvasHeight / 2, canvasWidth * 0.75
                    );
                    gradient.addColorStop(0, hexToRgba(settings.vignetteColor, 0));
                    gradient.addColorStop(1, hexToRgba(settings.vignetteColor, strength));
                    ctx.fillStyle = gradient;
                    drawRoundedRect(ctx, 0, 0, canvasWidth, canvasHeight, settings.radii);
                    ctx.fill();
                    ctx.restore();
                }
                return ctx.canvas;
            }

            // --- 4. 模块 A: 画框工坊 (V7 不变) ---
            function readFrameSettings() {
                frameSettings = {
                    aspectRatio: frameInputs.aspectRatio.value, fitMode: frameInputs.fitMode(),
                    frameType: frameInputs.frameType.value, frameColor1: frameInputs.frameColor1.value,
                    frameColor2: frameInputs.frameColor2.value, frameSize: parseInt(frameInputs.frameSize.value, 10),
                    matColor: frameInputs.matColor.value, matSize: parseInt(frameInputs.matSize.value, 10),
                    radii: {
                        tl: parseInt(frameInputs.radiusTL.value, 10), tr: parseInt(frameInputs.radiusTR.value, 10),
                        br: parseInt(frameInputs.radiusBR.value, 10), bl: parseInt(frameInputs.radiusBL.value, 10),
                    },
                    vignetteColor: frameInputs.vignetteColor.value, vignetteStrength: parseInt(frameInputs.vignetteStrength.value, 10),
                    shadowColor: frameInputs.shadowColor.value, shadowBlur: parseInt(frameInputs.shadowBlur.value, 10),
                    shadowOffsetX: parseInt(frameInputs.shadowOffsetX.value, 10), shadowOffsetY: parseInt(frameInputs.shadowOffsetY.value, 10),
                    filenameBase: frameInputs.filename.value || 'framed-image', format: frameInputs.format.value,
                };
            }
            async function handleImageUpload(e) {
                const files = e.target.files; if (!files || files.length === 0) return;
                imageList = []; currentPreviewIndex = 0;
                const loadPromises = Array.from(files).map(file => {
                    return new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onload = (event) => {
                            const img = new Image();
                            img.onload = () => { img.originalName = file.name; resolve(img); };
                            img.onerror = reject; img.src = event.target.result;
                        };
                        reader.onerror = reject; reader.readAsDataURL(file);
                    });
                });
                try { imageList = await Promise.all(loadPromises); } 
                catch (error) { console.error("加载图片时出错:", error); return; }
                if (imageList.length > 0) {
                    populateGallery(); setPreviewImage(0);
                    controlsWrapper.classList.remove('opacity-50', 'pointer-events-none');
                    galleryWrapper.classList.remove('hidden');
                    placeholder.style.display = 'none';
                    previewCanvas.style.display = 'block';
                }
            }
            function populateGallery() {
                imageGallery.innerHTML = '';
                imageList.forEach((img, index) => {
                    const thumb = document.createElement('img');
                    thumb.src = img.src; thumb.className = 'thumbnail';
                    thumb.dataset.index = index; thumb.title = img.originalName;
                    thumb.addEventListener('click', () => setPreviewImage(index));
                    imageGallery.appendChild(thumb);
                });
            }
            function setPreviewImage(index) {
                if (index < 0 || index >= imageList.length) return;
                currentPreviewIndex = index;
                Array.from(imageGallery.children).forEach((child, i) => {
                    child.classList.toggle('selected', i === index);
                });
                scheduleRedrawFrame();
            }
            let frameRedrawTimeout;
            function scheduleRedrawFrame() {
                if (frameRedrawTimeout) cancelAnimationFrame(frameRedrawTimeout);
                frameRedrawTimeout = requestAnimationFrame(redrawFramePreview);
            }
            function redrawFramePreview() {
                const currentImage = imageList[currentPreviewIndex]; if (!currentImage) return;
                readFrameSettings();
                drawFramedImage(previewCtx, currentImage, frameSettings, previewCanvas.parentElement.clientWidth, previewCanvas.parentElement.clientHeight);
            }
            async function batchExport() {
                if (imageList.length === 0) { alert('请先上传至少一张图片！'); return; }
                if (typeof JSZip === 'undefined') { alert('导出库 (JSZip) 加载失败。'); return; }
                downloadBtn.disabled = true;
                downloadBtnText.textContent = '正在打包... (0%)';
                downloadSpinner.classList.remove('hidden');
                const zip = new JSZip(); readFrameSettings();
                const format = frameSettings.format;
                const extension = format === 'image/jpeg' ? '.jpg' : '.png';
                const filenameBase = frameSettings.filenameBase;
                const renderCtx = frameRenderCanvas.getContext('2d');
                const baseResolution = 1500;
                for (let i = 0; i < imageList.length; i++) {
                    const image = imageList[i];
                    downloadBtnText.textContent = `正在打包... (${Math.round((i + 1) / imageList.length * 100)}%)`;
                    const originalRatio = image.width / image.height;
                    let targetRatio;
                    if (frameSettings.aspectRatio === 'original') { targetRatio = originalRatio; }
                    else if (frameSettings.aspectRatio === 'custom') { targetRatio = customFrameAspectRatio; }
                    else { const [w, h] = frameSettings.aspectRatio.split(':').map(Number); targetRatio = w / h; }
                    let w, h;
                    if (targetRatio > 1) { w = baseResolution; h = baseResolution / targetRatio; }
                    else { h = baseResolution; w = baseResolution * targetRatio; }
                    drawFramedImage(renderCtx, image, frameSettings, w, h);
                    const dataURL = frameRenderCanvas.toDataURL(format, format === 'image/jpeg' ? 0.95 : 1.0);
                    const base64Data = dataURL.split(',')[1];
                    const originalName = image.originalName.split('.').slice(0, -1).join('.');
                    const newFilename = `${filenameBase}-${originalName}-${i + 1}${extension}`;
                    zip.file(newFilename, base64Data, { base64: true });
                    await new Promise(resolve => setTimeout(resolve, 10)); 
                }
                downloadBtnText.textContent = '正在生成ZIP...';
                const blob = await zip.generateAsync({ type: "blob" });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = `${filenameBase}.zip`;
                link.click(); URL.revokeObjectURL(link.href);
                downloadBtn.disabled = false;
                downloadBtnText.textContent = '批量导出 (ZIP)';
                downloadSpinner.classList.add('hidden');
            }

            // --- 5. 模块 B: 照片墙 (V7 不变) ---
            function setupRatioPlanner(plannerEl, rectEl, onRatioUpdate) {
                let isDrawing = false;
                let startPos = { x: 0, y: 0 };
                let currentRect = { x: 0, y: 0, w: 0, h: 0 };
                function getCoords(e) {
                    const rect = plannerEl.getBoundingClientRect();
                    const x = Math.max(0, Math.min(e.clientX - rect.left, rect.width));
                    const y = Math.max(0, Math.min(e.clientY - rect.top, rect.height));
                    return { x, y };
                }
                function onDown(e) {
                    e.preventDefault(); isDrawing = true;
                    startPos = getCoords(e);
                    rectEl.style.display = 'block';
                    currentRect = { x: startPos.x, y: startPos.y, w: 0, h: 0 };
                    setDrawnRect(rectEl, currentRect);
                }
                function onMove(e) {
                    if (!isDrawing) return;
                    const currentPos = getCoords(e);
                    const x = Math.min(startPos.x, currentPos.x);
                    const y = Math.min(startPos.y, currentPos.y);
                    const w = Math.abs(currentPos.x - startPos.x);
                    const h = Math.abs(currentPos.y - startPos.y);
                    currentRect = { x, y, w, h };
                    setDrawnRect(rectEl, currentRect);
                }
                function onUp(e) {
                    if (!isDrawing) return;
                    isDrawing = false;
                    const { w, h } = currentRect;
                    if (w > 5 && h > 5) {
                        onRatioUpdate(w / h, currentRect);
                    } else {
                        const parentW = plannerEl.clientWidth;
                        const parentH = plannerEl.clientHeight;
                        currentRect = { x: 0, y: 0, w: parentW, h: parentH };
                        setDrawnRect(rectEl, currentRect);
                        onRatioUpdate(1.0, currentRect);
                    }
                }
                plannerEl.addEventListener('mousedown', onDown);
                document.addEventListener('mousemove', onMove);
                document.addEventListener('mouseup', onUp);
                plannerEl.addEventListener('mouseleave', (e) => {
                    if (isDrawing) onUp(e);
                });
                const parentW = plannerEl.clientWidth || 100;
                const parentH = plannerEl.clientHeight || 100;
                currentRect = { x: 0, y: 0, w: parentW, h: parentH };
                setDrawnRect(rectEl, currentRect);
            }
            function setDrawnRect(rectEl, rect) {
                const parentW = rectEl.parentElement.clientWidth;
                const parentH = rectEl.parentElement.clientHeight;
                if (parentW > 0 && parentH > 0) {
                    rectEl.style.left = `${(rect.x / parentW) * 100}%`;
                    rectEl.style.top = `${(rect.y / parentH) * 100}%`;
                    rectEl.style.width = `${(rect.w / parentW) * 100}%`;
                    rectEl.style.height = `${(rect.h / parentH) * 100}%`;
                    rectEl.style.display = 'block';
                }
            }
            async function generateAllFramedImages() {
                readFrameSettings();
                const baseResolution = 800;
                const promises = imageList.map(image => {
                    return new Promise(async (resolve) => {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        const originalRatio = image.width / image.height;
                        let targetRatio;
                        if (frameSettings.aspectRatio === 'original') { targetRatio = originalRatio; }
                        else if (frameSettings.aspectRatio === 'custom') { targetRatio = customFrameAspectRatio; }
                        else { const [w, h] = frameSettings.aspectRatio.split(':').map(Number); targetRatio = w / h; }
                        let w, h;
                        if (targetRatio > 1) { w = baseResolution; h = baseResolution / targetRatio; }
                        else { h = baseResolution; w = baseResolution * targetRatio; }
                        drawFramedImage(ctx, image, frameSettings, w, h);
                        await new Promise(r => requestAnimationFrame(r)); 
                        resolve(canvas);
                    });
                });
                return Promise.all(promises);
            }
            async function renderWall() {
                if (isWallRendering || imageList.length === 0) return;
                isWallRendering = true;
                exportWallBtn.disabled = true;
                exportWallSpinner.classList.remove('hidden');
                exportWallBtnText.textContent = '正在智能布局...';

                const framedCanvases = await generateAllFramedImages();
                const layoutMode = layoutModeSelect.value;
                const compactness = parseInt(wallCompactnessSlider.value, 10);
                let layout = [];
                let totalWidth = 0;
                let totalHeight = 0;
                
                if (layoutMode === 'masonry') {
                    const gap = compactness / 2;
                    const baseSize = 300;
                    const result = findBestMasonryLayout(framedCanvases, baseSize, gap, wallTargetAspectRatio);
                    layout = result.layout;
                    totalWidth = result.totalWidth;
                    totalHeight = result.totalHeight;
                } else if (layoutMode === 'random') {
                    const scale = (compactness / 100) * 1.5 + 0.5;
                    const result = layoutRandom(framedCanvases, scale, wallTargetAspectRatio);
                    layout = result.layout;
                    totalWidth = result.totalWidth;
                    totalHeight = result.totalHeight;
                }

                wallCanvas.width = totalWidth;
                wallCanvas.height = totalHeight;
                wallCtx.clearRect(0, 0, totalWidth, totalHeight);
                
                layout.forEach(item => {
                    if (item.rotation) {
                        wallCtx.save();
                        wallCtx.translate(item.x + item.width / 2, item.y + item.height / 2);
                        wallCtx.rotate(item.rotation);
                        wallCtx.drawImage(item.canvas, -item.width / 2, -item.height / 2, item.width, item.height);
                        wallCtx.restore();
                    } else {
                        wallCtx.drawImage(item.canvas, item.x, item.y, item.width, item.height);
                    }
                });

                isWallRendering = false;
                exportWallBtn.disabled = false;
                exportWallSpinner.classList.add('hidden');
                exportWallBtnText.textContent = '导出照片墙 (PNG)';
            }
            function findBestMasonryLayout(canvases, baseSize, gap, targetRatio) {
                let bestMatch = { diff: Infinity, layout: [], totalWidth: 0, totalHeight: 0 };
                const maxChecks = Math.max(2, Math.min(8, canvases.length));
                for (let cols = 2; cols <= maxChecks; cols++) {
                    const result = calculateMasonryLayout('vertical', canvases, cols, baseSize, gap);
                    if (result.totalHeight === 0) continue;
                    const actualRatio = result.totalWidth / result.totalHeight;
                    const diff = Math.abs(actualRatio - targetRatio);
                    if (diff < bestMatch.diff) { bestMatch = { ...result, diff }; }
                }
                for (let rows = 2; rows <= maxChecks; rows++) {
                    const result = calculateMasonryLayout('horizontal', canvases, rows, baseSize, gap);
                    if (result.totalWidth === 0) continue;
                    const actualRatio = result.totalWidth / result.totalHeight;
                    const diff = Math.abs(actualRatio - targetRatio);
                    if (diff < bestMatch.diff) { bestMatch = { ...result, diff }; }
                }
                return bestMatch;
            }
            function calculateMasonryLayout(direction, canvases, fixedCount, baseSize, gap) {
                let layout = [];
                if (direction === 'vertical') {
                    let columnHeights = Array(fixedCount).fill(0);
                    canvases.forEach(canvas => {
                        const minHeight = Math.min(...columnHeights);
                        const colIndex = columnHeights.indexOf(minHeight);
                        const scale = baseSize / canvas.width;
                        const itemHeight = canvas.height * scale;
                        const itemWidth = baseSize;
                        const x = colIndex * (baseSize + gap);
                        const y = minHeight;
                        layout.push({ canvas: canvas, x, y, width: itemWidth, height: itemHeight });
                        columnHeights[colIndex] += itemHeight + gap;
                    });
                    const totalWidth = fixedCount * baseSize + (fixedCount - 1) * gap;
                    const totalHeight = Math.max(...columnHeights) - gap;
                    return { layout, totalWidth, totalHeight };
                } else {
                    let rowWidths = Array(fixedCount).fill(0);
                    canvases.forEach(canvas => {
                        const minWidth = Math.min(...rowWidths);
                        const rowIndex = rowWidths.indexOf(minWidth);
                        const scale = baseSize / canvas.height;
                        const itemWidth = canvas.width * scale;
                        const itemHeight = baseSize;
                        const x = minWidth;
                        const y = rowIndex * (baseSize + gap);
                        layout.push({ canvas: canvas, x, y, width: itemWidth, height: itemHeight });
                        rowWidths[rowIndex] += itemWidth + gap;
                    });
                    const totalWidth = Math.max(...rowWidths) - gap;
                    const totalHeight = fixedCount * baseSize + (fixedCount - 1) * gap;
                    return { layout, totalWidth, totalHeight };
                }
            }
            function layoutRandom(canvases, scaleFactor, targetRatio) {
                let layout = [];
                let positions = [];
                const baseImageSize = 800 * (1 / scaleFactor);
                const areaPerImage = Math.pow(baseImageSize, 2);
                const totalArea = canvases.length * areaPerImage;
                const boxHeight = Math.sqrt(totalArea / targetRatio) * 1.2;
                const boxWidth = boxHeight * targetRatio;
                let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                canvases.forEach(canvas => {
                    const itemWidth = (canvas.width / 2) * scaleFactor;
                    const itemHeight = (canvas.height / 2) * scaleFactor;
                    const x = Math.random() * (boxWidth - itemWidth);
                    const y = Math.random() * (boxHeight - itemHeight);
                    const rotation = (Math.random() - 0.5) * 0.2;
                    positions.push({ x, y, width: itemWidth, height: itemHeight });
                    layout.push({ canvas: canvas, x, y, width: itemWidth, height: itemHeight, rotation });
                    minX = Math.min(minX, x); maxX = Math.max(maxX, x + itemWidth);
                    minY = Math.min(minY, y); maxY = Math.max(maxY, y + itemHeight);
                });
                const finalLayout = layout.map(item => ({ ...item, x: item.x - minX, y: item.y - minY }));
                const totalWidth = maxX - minX;
                const totalHeight = maxY - minY;
                return { layout: finalLayout, totalWidth, totalHeight };
            }
            async function exportWall() {
                if (isWallRendering) { alert("请等待当前布局渲染完成。"); return; }
                await renderWall();
                const dataURL = wallCanvas.toDataURL('image/png');
                const link = document.createElement('a');
                link.href = dataURL;
                link.download = 'photo-wall.png';
                link.click();
            }

            // --- 6. 辅助函数 (V7 不变) ---
            function drawRoundedRect(ctx, x, y, w, h, r) {
                const maxRad = Math.min(w / 2, h / 2);
                r = { tl: Math.min(r.tl, maxRad), tr: Math.min(r.tr, maxRad), br: Math.min(r.br, maxRad), bl: Math.min(r.bl, maxRad) };
                ctx.beginPath(); ctx.moveTo(x + r.tl, y);
                ctx.lineTo(x + w - r.tr, y); ctx.arcTo(x + w, y, x + w, y + r.tr, r.tr);
                ctx.lineTo(x + w, y + h - r.br); ctx.arcTo(x + w, y + h, x + w - r.br, y + h, r.br);
                ctx.lineTo(x + r.bl, y + h); ctx.arcTo(x, y + h, x, y + h - r.bl, r.bl);
                ctx.lineTo(x, y + r.tl); ctx.arcTo(x, y, x + r.tl, y, r.tl);
                ctx.closePath();
            }
            function getInnerRadii(outerRadii, inset) {
                return { tl: Math.max(0, outerRadii.tl - inset), tr: Math.max(0, outerRadii.tr - inset), br: Math.max(0, outerRadii.br - inset), bl: Math.max(0, outerRadii.bl - inset) };
            }
            function getFillStyle(ctx, type, x, y, w, h) {
                switch (type) {
                    case 'gradient':
                        const gradient = ctx.createLinearGradient(x, y, w, h);
                        gradient.addColorStop(0, frameSettings.frameColor1); gradient.addColorStop(1, frameSettings.frameColor2);
                        return gradient;
                    case 'wood': return texturePatterns.wood; case 'stipple': return texturePatterns.stipple;
                    case 'stripes': return texturePatterns.stripes; case 'checker': return texturePatterns.checker;
                    case 'solid': default: return frameSettings.frameColor1;
                }
            }
            function hexToRgba(hex, alpha) {
                const r = parseInt(hex.slice(1, 3), 16), g = parseInt(hex.slice(3, 5), 16), b = parseInt(hex.slice(5, 7), 16);
                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
            }
            function updatePatterns() {
                readFrameSettings();
                const c1 = frameInputs.frameColor1.value; const c2 = frameInputs.frameColor2.value;
                texturePatterns.wood = createWoodPattern(c1, c2); texturePatterns.stipple = createStipplePattern(c1, c2);
                texturePatterns.stripes = createStripesPattern(c1, c2); texturePatterns.checker = createCheckerPattern(c1, c2);
                if (imageList.length > 0) scheduleRedrawFrame();
            }
            function createWoodPattern(c1, c2) { 
                textureCanvas.width = 100; textureCanvas.height = 100;
                textureCtx.fillStyle = c1; textureCtx.fillRect(0, 0, 100, 100);
                textureCtx.strokeStyle = c2; textureCtx.lineWidth = 1;
                for (let i = 0; i < 20; i++) {
                    textureCtx.beginPath(); textureCtx.moveTo(Math.random() * 100, 0);
                    textureCtx.bezierCurveTo(Math.random() * 100, 25, Math.random() * 100, 75, Math.random() * 100, 100);
                    textureCtx.stroke();
                } return previewCtx.createPattern(textureCanvas, 'repeat');
            }
            function createStipplePattern(c1, c2) {
                textureCanvas.width = 50; textureCanvas.height = 50;
                textureCtx.fillStyle = c1; textureCtx.fillRect(0, 0, 50, 50);
                textureCtx.fillStyle = c2;
                for (let i = 0; i < 100; i++) {
                    textureCtx.globalAlpha = Math.random() * 0.5;
                    textureCtx.beginPath(); textureCtx.arc(Math.random() * 50, Math.random() * 50, Math.random() * 1.5, 0, Math.PI * 2); textureCtx.fill();
                } textureCtx.globalAlpha = 1.0;
                return previewCtx.createPattern(textureCanvas, 'repeat');
            }
            function createStripesPattern(c1, c2) {
                textureCanvas.width = 10; textureCanvas.height = 10;
                textureCtx.fillStyle = c1; textureCtx.fillRect(0, 0, 10, 10);
                textureCtx.fillStyle = c2; textureCtx.fillRect(0, 0, 5, 10);
                return previewCtx.createPattern(textureCanvas, 'repeat');
            }
            function createCheckerPattern(c1, c2) {
                textureCanvas.width = 20; textureCanvas.height = 20;
                textureCtx.fillStyle = c1; textureCtx.fillRect(0, 0, 20, 20);
                textureCtx.fillStyle = c2;
                textureCtx.fillRect(0, 0, 10, 10); textureCtx.fillRect(10, 10, 10, 10);
                return previewCtx.createPattern(textureCanvas, 'repeat');
            }
            function toggleRadiusLock() { 
                isRadiusLocked = !isRadiusLocked;
                lockRadiusBtn.classList.toggle('locked', isRadiusLocked);
                lockRadiusBtn.classList.toggle('unlocked', !isRadiusLocked);
                lockIcon.classList.toggle('hidden', !isRadiusLocked);
                unlockIcon.classList.toggle('hidden', isRadiusLocked);
                if (isRadiusLocked) {
                    const masterValue = frameInputs.radiusTL.value;
                    radiusSliders.forEach(slider => slider.value = masterValue);
                    scheduleRedrawFrame();
                }
            }
            function handleRadiusChange(e) {
                if (isRadiusLocked) {
                    const newValue = e.target.value;
                    radiusSliders.forEach(slider => slider.value = newValue);
                }
                scheduleRedrawFrame();
            }
            
            // --- 7. 启动 ---
            init();
        });
    </script>
</body>
</html>